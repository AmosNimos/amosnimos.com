<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Overlord Ascension</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=New+Rocker&display=swap" rel="stylesheet">
</head>
<body>

    <div style="position: relative;">
      <img src="banners/banner_001.jpg" style="margin: 0; left: 0; width: 100%; height: auto;">
      
      <!-- Gradient Overlay -->
      <div style="position: absolute; bottom: 0; left: 0; right: 0; height: 50%; background: linear-gradient(to top, #333333, rgba(0, 0, 0, 0));"></div>

      <!-- Title and Subtitle -->
      <div style="position: absolute; bottom: 20%; left: 50%; transform: translateX(-50%); text-align: center; color: white;">
        <h1 style="font-family: 'New Rocker', cursive; font-size: 9em; text-shadow: 0.1em 0.1em 0.5em rgba(100, 0, 0, 1); margin: 0; color: #FFFFFF">Demonlord Ascension</h1>
      </div>
    </div>
    
    <div class="button-container">
        <button class="nav-button" id="toggle-music-btn">Play Music</button>
        <button class="nav-button" onclick="confirmAscension()">Ascend</button>
    </div>

    <audio id="background-music" src="music/track1.mp3"></audio>

    <script>
        const music = document.getElementById('background-music');
        const button = document.getElementById('toggle-music-btn');

        // Set volume to 0.3 (30%)
        music.volume = 0.3;

        // Function to play music
        function playMusic() {
            music.play();
            music.loop = true;
            button.textContent = 'Stop Music'; // Change button text
        }

        // Function to stop music
        function stopMusic() {
            music.pause();
            music.currentTime = 0; // Reset the music to the start
            button.textContent = 'Play Music'; // Change button text
        }

        // Button click event listener to toggle play/stop music
        button.addEventListener('click', () => {
            if (music.paused || music.ended) {
                playMusic(); // Start music if itâ€™s not playing
            } else {
                stopMusic(); // Stop music if it's playing
            }
        });
    </script>

    <script>
    function confirmAscension() {
        const confirmation = confirm(
            "Warning: Ascending to a new body will cause you to lose all your skills, but some of your knowledge will be passed on to your next self, making training faster in the next life.\n\nAre you sure you want to ascend?"
        );

        if (confirmation) {
            executeAscension();
        }
    }
    </script>

    <h2>Abilities:</h2>

    <div id="skills-container"></div>

    <script>
        let level = 1;
        let xp = 0;
        let ascension_level = 1;
        let xpGoal = 2;

        let skillLevels = [];
        let skillProgress = [];
        let skillGoals = [];
        let skillNames = [];
        let skillTrainingActive = [];  // To track if training is active for a skill
        let skillIcons = [];
        let skillHueShifts = [];
        let progressDelay = 2;

        // Clear localStorage and reset data
        function executeAscension() {
            localStorage.removeItem('skillsData');
            localStorage.removeItem('playerData');
            skillLevels = [];
            skillProgress = [];
            skillGoals = [];
            skillNames = [];
            skillTrainingActive = [];  // To track if training is active for a skill
            skillIcons = [];
            skillHueShifts = [];
            if( level > ascension_level){
                // Increase player progress speed
                ascension_level=level;
            } else {
                ascension_level=1;
            }
            level = 1;
            xp = 0;
            xpGoal = 2;
            addNewSkill(); // Create the first skill if none exist
            saveSkillsToStorage();
            alert("Reincarnation complete. You are reborn!");
            location.reload();
        }

        /// BACKGROUND MUSIC
        // Function to play background music in a loop
        function playBackgroundMusic(index = 0) {
            // Define an array of background music file paths
            const tracks = [
                'musics/track1.mp3', // index 0
                'musics/track2.mp3', // index 1
            ];

            // Ensure the index is within the bounds of the array
            const track = tracks[index] || tracks[0]; // Default to index 0 if out of bounds

            // Create a single audio instance to play the background music
            const backgroundAudio = new Audio(track);
            backgroundAudio.loop = true; // Enable looping

            backgroundAudio.play();

            return backgroundAudio; // Return the audio instance for potential control (e.g., pause or stop)
        }

        /// SOUNDS
        // Function to play a system notification sound (a victory bell or similar)
        function playNotificationSound(index = 0) {
            // Define an array of sound file paths
            const sounds = [
                'sounds/win.mp3',  // index 0
                'sounds/level.mp3', // index 1
                'sounds/select.mp3', // index 2
            ];

            // Make sure the index is within the bounds of the array
            const sound = sounds[index] || sounds[0];  // Default to index 0 if out of bounds

            const audio = new Audio(sound);
            audio.play();
        }

        // Images
        const iconsDir = 'icons/ability';

        // Render skills from the loaded data
        function renderSkills() {
            const skillsContainer = document.getElementById("skills-container");
            skillsContainer.innerHTML = ''; // Clear existing skills

            for (let skillID = 0; skillID < skillLevels.length; skillID++) {
                const skillName = skillNames[skillID];
                const skillLevel = skillLevels[skillID];
                const skillGoal = skillGoals[skillID];
                const skillProgressValue = skillProgress[skillID];
                const skillIcon = skillIcons[skillID];  // Fix the typo from skillIconss to skillIcons
                const hueShift = skillHueShifts[skillID] || 0;
                
                // Create the skill element
                const newSkill = document.createElement("div");
                newSkill.classList.add("skill");
                newSkill.innerHTML = `
                    <div class="SkillHeader">
                        <img class="SkillIcon" src="${skillIcon}" alt="${skillName} icon" style="filter: hue-rotate(${hueShift}deg);">
                        <h3 id="skill-${skillID}-name">${skillName} LV: ${skillLevel}</h3>                    
                    </div>
                    <div class="training">
                        <div class="progress-container">
                            <div id="skill-${skillID}" class="progress-bar" style="width: ${Math.round((skillProgressValue / skillGoal) * 100)}%;">${Math.round((skillProgressValue / skillGoal) * 100)}%</div>
                        </div>
                        <button id="train-btn-${skillID}" onclick="startTraining(${skillID})">Train ${skillName}</button>
                    </div>
                `;

                // Append the new skill to the container
                skillsContainer.appendChild(newSkill);
            }
        }

        // Save skills and player data to localStorage
        function saveSkillsToStorage() {
            const skillsData = { skillLevels, skillProgress, skillGoals, skillNames, skillIcons, skillHueShifts };
            localStorage.setItem('skillsData', JSON.stringify(skillsData));
            const playerData = { xp, xpGoal, level, ascension_level };
            localStorage.setItem('playerData', JSON.stringify(playerData));
        }

        // Load skills and player data from localStorage
        function loadSkillsFromStorage() {
            const storedSkillsData = localStorage.getItem('skillsData');
            if (storedSkillsData) {
                const { skillLevels: storedLevels, skillProgress: storedProgress, skillGoals: storedGoals, skillNames: storedNames, skillIcons: storedIcons, skillHueShifts: storedHueShifts } = JSON.parse(storedSkillsData);
                skillLevels = storedLevels || [];
                skillProgress = storedProgress || [];
                skillGoals = storedGoals || [];
                skillNames = storedNames || [];
                skillIcons = storedIcons || ['icons/default-icon.png'];  // Default fallback
                skillHueShifts = storedHueShifts || [];  // Fix this line
            } else {
                // If no skills data exists, create default skills
                addNewSkill(); // Create the first skill if none exist
            }

            const storedPlayerData = localStorage.getItem('playerData');
            if (storedPlayerData) {
                const { xp: storedXp, xpGoal: storedXpGoal, level: storedLevel, ascension_level: storedAscension  } = JSON.parse(storedPlayerData);
                xp = storedXp || 0;
                xpGoal = storedXpGoal || 5;
                level = storedLevel || 1;
                ascension_level  = storedAscension || 1;
            }
        }

        // Generate a random skill name
        function generateSkillName() {
            const firstPart = [
                "Sinful", "Ruthless", "Evil", "Netherworld", "Merciless", "Colossal", "Monstrous", "Brutal","Cruel", "Inhumane","Berserk", "Immortal","Dark", "Shadow", "Poison", "Death", "Darkness", "Void", "Demonic", 
                "Cursed", "Blood", "Damnation", "Inferno", "Undead", "Dead", "Abyss", "Abyssal", "Soul", "Blight", "Nightmare", "Night", "Moonlight",
                "Infernal", "Hell", "Hellish", "Grim", "Eternal", "Vile", "Malice", 
                "Wicked", "Necrotic", "Corrupt", "Searing", "Feral", "Unholy", "Phantom",
                "Malevolent", "Sinister", "Diabolic", "Gore", "Ruinous", "Tormented", "Fiendish",
                "Desolate", "Forsaken", "Accursed", "Devilish", "Blackened", "Ravaged",
                "Lurking", "Tainted", "Oblivion", "Profane", "Venomous", "Chaotic", 
                "Shattered", "Tragic", "Calamitous", "Cataclysmic", "Dire", "Twisted", "Unlit", "Ominous", "Morbid", "Spectral",
                "Decayed", "Atomic", "Vicious","Dreadful", "Ghastly", "Hateful", "Spiteful", "Acheron", "Damned", "Corrupted",
                "Malevolent", "Maledict", "Dread", "Gloom", "Despair", "Frenzied", "Harbinger", "Vampiric", "Vengeful", "Celestial", "Disturbing", "Haunted", "Lich", "Mind", "Aura of ", "Auspicious", "Elemental", "Ether", "Ghostly", "Guilt", "Soulless", "Cultist", "Divine", "Unyielding", "Relic", "Merciful", "Unfortunate", "Wretched", "Deep", "Eldritch", "Emptiness", "Baneful", "Ancient", "Acid", "Madness", "Unkind", "Mean", "Dominant", "Supreme", "Powerful", "Superior", "Outrageous", "Super", "Explosive", "Obscure", "Shrouded", "Psychic", "Astral", "Otherworldly", "Paranormal", "Prophet", "Telekinesis", "Blasphemy", "Ethereal", "Stellar", "Reality", "Galactic", "Astronomical", "Nightfall", "Menacing", "Terrifying", "Midnight", "Eclipse", "Nocturnal", "Ravenous", "Mythic", "Arcane", "Runic", "Echanted", "Fractured", "Anarchic", "Pandemonic", "Unfettered", "Wild", "Unleashed", "Nebulous", "Cosmic", "Singular", "Quantum", "Antimatter", "Seismic", "Dual", "Triple", "Centuple", "Manifold", "Relentless", "Thousands", "Million", "Billion", "Infinite", "Limitless", "fathomless", "Godly", "Boundless", "Virtual", "Painful"
            ];
            const secondPart = [
                "Punch", "Bolt", "Blast", "Beam", "Laser", "Bullet", "Wave", "Pulse", "Cannon", 
                "Orb", "Dart", "Surge", "Jet", "Arrow", "Spear", "Bomb", "Strike", 
                "Bind","Grasp", "Superheat", "Rush",
                "Burst", "Cloak", "Fang", "Vortex", "Storm", "Howl", "Touch", "Flare", "Fist",
                "Corrosion", "Decay", "Shred", "Pierce", "Eruption", "Pain", "Ruin", "Slash",
                "Scourge", "Implosion", "Detonation", "Crush", "Venom", "Crack", "Splinter",
                "Meltdown", "Sear", "Vapor", "Fracture", "Release", "Annihilation", "Scald",
                "Smash", "Injection", "Tear", "Dissolution", "Quake", "Fragment", "Collapse",
                "Disintegrate", "Atomizer", "Evaporate", "Breakdown", "Engulf", "Devastation", "Assault", "Maelstrom", "Bender", "Flux", "Power", "Leech", "Lock", "Spike", "Burden", "Disruption", "Fear", "Echo", "Agony", "Suffering", "Torment", "Affliction", "Blaze", "Incantation", "Renewal", "Haste", "Immolation", "Sacrifice", "Subversion", "Shame", "Form", "Thorns", "Equinox", "Mist", "Flesh", "Silence", "Vow", "Possession", "Atrocity", "Misery", "Sorrow", "Abomination", "Trap", "Explosion", "Boom", "Thunder", "Fire", "Fireball", "Hex", "Flame", "Rain", "Punishment", "Purgatory", "Tribulation", "Trauma", "Burial", "Entombment", "Breath", "Sinestra", "Voodoo", "Skinning", "Malediction", "Eye", "Swamp", "Descend", "Ruling", "Invocation", "Summoning", "Torrent", "Nova", "Whirlwind", "Chant", "Manifestation", "Barrage", "Charge", "Leach", "Tempest", "Cyclone", "Typhoon", "Hurricane", "Tornado", "Terrors", "Trial", "Being", "Mana", "Saw", "Blade", "Bleed", "Absorption", "Assimilation", "Intimidation", "Javelin", "Harpoon", "Spire", "Dagger", "Whip", "Cataclysm", "Combustion", "Ray", "Arc", "Current", "Discruption", "Seal", "Clash", "Ram", "Spite", "Wraith", "Claw", "Gaze", "Stare", "Pressure", "Influence", "Impact", "Authority", "World", "Corruption", "Manipulation", "Control", "Puppeteering", "Hypnosis", "Chains", "Dissection", "Ritual", "Plasma", "Rage"
            ];

            return firstPart[Math.floor(Math.random() * firstPart.length)] + " " + secondPart[Math.floor(Math.random() * secondPart.length)];
        }

        // Add new skill
        function addNewSkill() {
            const skillID = skillLevels.length;

            let skillName = generateSkillName();
            let attempt=0;

            // Keep generating a new name if it exists in the list, up to 100 times
            if (Array.isArray(skillNames) && skillNames.length > 0) {
                while (skillNames.includes(skillName) && attempts < 100) {
                    skillName = generateSkillName();
                    attempts++;
                }
            }
            const skillGoal = 1;

            if (skillID > 0) {
                playNotificationSound();  // Play the sound when level-up is achieved
                alert(`Skill [${skillName}] Acquired!`);
            }

            skillNames[skillID] = skillName;
            skillLevels[skillID] = 1;
            skillGoals[skillID] = skillGoal;
            skillProgress[skillID] = 0;
            skillTrainingActive[skillID] = false;  // Start with training inactive
            
            // Generate a random integer between 1 and icon_count (formatted as 3-digit string)
            const icon_count = 255;
            const randomIconNumber = String(Math.floor(Math.random() * icon_count + 1)).padStart(3, '0');
            skillIcons[skillID] = iconsDir + randomIconNumber + ".png";
            
            // Generate random hue shift (between 0 and 360 degrees)
            const randomHueShift = Math.floor(Math.random() * 360);

            // Store the hue shift in skill data
            skillHueShifts[skillID] = randomHueShift;

            const newSkill = document.createElement("div");
            newSkill.classList.add("skill");
            newSkill.innerHTML = `
                <div class="SkillHeader">
                    <img class="SkillIcon" src="${skillIcons[skillID]}" alt="Skill Icon" style="filter: hue-rotate(${randomHueShift}deg);">
                    <h3 id="skill-${skillID}-name">${skillName} LV: ${skillLevels[skillID]}</h3>
                </div>
                <div class="progress-container">
                    <div id="skill-${skillID}" class="progress-bar" style="width: 0%;">0%</div>
                </div>
                <button id="train-btn-${skillID}" onclick="startTraining(${skillID})">Train ${skillName}</button>
            `;
            document.getElementById("skills-container").appendChild(newSkill);

            // Start auto-training for the skill
            //startTraining(skillID);

            saveSkillsToStorage();
        }


        // Start the training for a skill
        function startTraining(skillID) {
            playNotificationSound(2);  // Play the sound when level-up is achieved
            const trainButton = document.getElementById(`train-btn-${skillID}`);
            if (trainButton.disabled) return; // Prevent starting training if already completed

            skillTrainingActive[skillID] = true;
            trainButton.disabled = true; // Disable the button during training

            const interval = setInterval(() => {
                if (!skillTrainingActive[skillID]) {
                    clearInterval(interval);
                    return;
                }

                skillProgress[skillID] += ascension_level / 10; // Increase progress over time
                updateProgressBar(skillID); // Update the progress bar

                if (skillProgress[skillID] >= skillGoals[skillID]) {
                    clearInterval(interval); // Stop training once it reaches 100%
                    skillLevels[skillID]++; // Level up the skill

                    // Wait a bit to allow progress bar to reach 100% before resetting
                    setTimeout(() => {
                        skillProgress[skillID] = 0; // Reset progress for next level
                        skillGoals[skillID] *= progressDelay;
                        xp++; // Increase player's XP
                        if (xp >= xpGoal) {
                            xp = 0;
                            xpGoal *= progressDelay;
                            level++;
                            addNewSkill(); // Automatically add a new skill when level up
                        }

                        // Update the progress bar and re-enable the training button
                        updateProgressBar(skillID); // Reset progress bar after level up
                        document.getElementById(`train-btn-${skillID}`).disabled = false; // Re-enable the button

                        // Update skill level display
                        const skillNameElement = document.getElementById(`skill-${skillID}-name`);
                        skillNameElement.innerText = `${skillNames[skillID]} LV: ${skillLevels[skillID]}`;

                        saveSkillsToStorage(); // Save the updated data

                        // LEVEL UP!
                        playNotificationSound(1);  // Play the sound when level-up is achieved
                        alert(`Skill [${skillNames[skillID]}] leveled up!`);
                    }, 100); // Wait 100ms before resetting progress
                }
            }, 100); // Update progress every 100ms
        }

        // Update the progress bar
        function updateProgressBar(skillID) {
            if (skillProgress[skillID] > skillGoals[skillID]) {
                skillProgress[skillID] = skillGoals[skillID];
            }
            const progress = Math.min((skillProgress[skillID] / skillGoals[skillID]) * 100, 100);
            const bar = document.getElementById(`skill-${skillID}`);
            const skillNameElement = document.getElementById(`skill-${skillID}-name`);
            bar.style.width = `${progress}%`;
            bar.textContent = `${Math.round(progress)}%`;

            // Disable the button when training is completed (100%)
            const trainButton = document.getElementById(`train-btn-${skillID}`);
            //if (progress === 100) {
                // LEVEL UP!
                //playNotificationSound(1);  // Play the sound when level-up is achieved
                //alert(`Skill [${skillNames[skillID]}] leveled up!`);
                //trainButton.disabled = true;  // Disable the button when progress reaches 100%
            //}
        }



        // Load skills on page load
        loadSkillsFromStorage();
        renderSkills(); // Render the skills after loading from storage

    </script>
</body>
</html>
